{"version":3,"sources":["src/PostSortLoader.js"],"names":["PostSortLoader","createSignatureRequest","createContentItemRequest","sortingFunction","options","optionsDefaults","targetCount","batchNumber","batchMaxEntries","shouldBatchContinue","filterSignature","sig","i","a","endReached","contentSignaturesPool","customLoadNumber","rawPool","length","getSignatures","contentToRequest","splice","entry","eI","rI","key","request","method","endpoint","contentsResponse","allSignatures","undefined","remainingSignatures","list","filter","item","error","map","data","reason","batchArray","push","batchPageIndex","entryIndex","requestIndex","maxEntries","response","signatures","chunk","status","reduce","accum","current","concat","index","all","sortedSignatures","sort","console","log"],"mappings":"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","file":"PostSortLoader.js","sourcesContent":["import { promiseRestBatch } from './fetchPromise'\n\n//todo: so far works with REST batch (not OSAPI) and doesn't load more than required initially (no\n// full support of \"load more\")\nexport default class PostSortLoader {\n  constructor (createSignatureRequest, createContentItemRequest, sortingFunction, options) {\n\n    const optionsDefaults = {\n      // how many items of final sorted content we want to load per each \"loadNext\"\n      targetCount: 10,\n\n      //how many batched pages of signature requests to perform\n      batchNumber: 5,\n\n      // jive batch can take no more than 25 requests per batch. 25 is a default, but we're\n      // putting it here explicitly.\n      // In many cases it's better to ask for signatures in smaller chunks - like 10 times per\n      // 100 items makes it 1000 items per page, but we can stop after each thousand and run\n      // shouldBatchContinue to avoid loading too much content\n      batchMaxEntries: 25,\n\n      // function that runs after each batch page. If it returns false - batching should stop\n      shouldBatchContinue: null,\n\n      // function to filter out some signatures before fetching of real data starts. For example\n      // we want to disable of loading some IDs\n      filterSignature: (sig, i, a) => sig\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    //global flag telling us that we should stop polling.\n    this.endReached = false\n\n    //main functions from params\n    this.createSignatureRequest = createSignatureRequest\n    this.createContentItemRequest = createContentItemRequest\n    this.sortingFunction = sortingFunction\n\n    //collection of just IDs and fields by which content is sorted\n    this.contentSignaturesPool = []\n  }\n\n  async loadNext (customLoadNumber = 0) {\n    // if poll is empty and end is not reached (means this is first calling of loadNext) -\n    // get those signatures!\n    let rawPool = []\n    if (!this.contentSignaturesPool.length && !this.endReached) {\n      rawPool = await this.getSignatures()\n      this.contentSignaturesPool = [...rawPool]\n    }\n\n    // as long as pool has data - slice in targetCount/customLoadNumber and get individual items\n    if (this.contentSignaturesPool.length) {\n      const contentToRequest = this.contentSignaturesPool.splice(0, customLoadNumber || this.options.targetCount)\n\n      // but if this was the last slice - flag the \"endReached\"\n      if (!this.contentSignaturesPool.length) {\n        this.endReached = true\n      }\n\n      const contentsResponse = await promiseRestBatch(contentToRequest, (entry, eI, rI) => {\n        return {\n          key: rI + '.' + eI,\n          request: {\n            method: 'GET',\n            endpoint: this.createContentItemRequest(entry)\n          }\n        }\n      })\n\n      //todo: figure out what to do with errors inside this list (now they're just ignored)\n      return {\n        allSignatures: rawPool.length ? rawPool : undefined,\n        remainingSignatures: [...this.contentSignaturesPool],\n        list: contentsResponse\n          .filter(item => !item.error)\n          .map(item => item.data),\n        reason: this.endReached ? 'source ended' : 'reached target count'\n      }\n    } else {\n      return {\n        allSignatures: rawPool.length ? rawPool : undefined,\n        remainingSignatures: [...this.contentSignaturesPool],\n        list: [],\n        reason: 'polling finished'\n      }\n    }\n  }\n\n  async getSignatures () {\n    const {\n      batchNumber,\n      filterSignature\n    } = this.options\n\n    const batchArray = []\n    for (let i = 0; i < batchNumber; i++) batchArray.push(i)\n\n    const response = await promiseRestBatch(batchArray, (batchPageIndex, entryIndex, requestIndex) => {\n      return {\n        key: requestIndex + '.' + entryIndex,\n        request: {\n          method: 'GET',\n          endpoint: this.createSignatureRequest(batchPageIndex)\n        }\n      }\n    }, {\n      maxEntries: this.options.batchMaxEntries,\n      shouldBatchContinue: this.options.shouldBatchContinue\n    })\n\n    //todo: figure out what to do with errors inside this list (now they're just ignored)\n    const signatures = response\n      .filter(chunk => chunk.status === 200)\n      .map(chunk => chunk.data.list)\n      .reduce((accum, current) => accum.concat(current), [])\n      .filter((sig, index, all) => filterSignature(sig, index, all))\n\n    const sortedSignatures = signatures.sort(this.sortingFunction)\n\n    console.log('response', response)\n    console.log('sortedSignatures', sortedSignatures)\n\n    return sortedSignatures\n  }\n}\n"]}