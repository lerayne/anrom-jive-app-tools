{"version":3,"sources":["src/PostSortLoader.js"],"names":["PostSortLoader","createSignatureRequest","createContentItemRequest","sortingFunction","options","optionsDefaults","targetCount","batchNumber","batchMaxEntries","shouldBatchContinue","filterSignature","sig","endReached","contentSignaturesPool","customLoadNumber","length","getSignatures","contentToRequest","splice","entry","eI","rI","key","request","method","endpoint","contentsResponse","list","filter","item","error","map","data","reason","batchArray","i","push","batchPageIndex","entryIndex","requestIndex","maxEntries","response","signatures","chunk","status","reduce","accum","current","concat","sortedSignatures","sort","console","log"],"mappings":"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","file":"PostSortLoader.js","sourcesContent":["import { promiseRestBatch } from '../fetchPromise'\n\n//todo: so far works with OSAPI batch (not REST) and doesn't load more than required initially (no\n// full support of \"load more\")\nexport default class PostSortLoader {\n  constructor (createSignatureRequest, createContentItemRequest, sortingFunction, options) {\n\n    const optionsDefaults = {\n      // how many items of final sorted content we want to load per each \"loadNext\"\n      targetCount: 10,\n\n      //how many batched pages of signature requests to perform\n      batchNumber: 5,\n\n      // jive batch can take no more than 25 requests per batch. 25 is a default, but we're\n      // putting it here explicitly.\n      // In many cases it's better to ask for signatures in smaller chunks - like 10 times per\n      // 100 items makes it 1000 items per page, but we can stop after each thousand and run\n      // shouldBatchContinue to avoid loading too much content\n      batchMaxEntries: 25,\n\n      // function that runs after each batch page. If it returns false - batching should stop\n      shouldBatchContinue: null,\n\n      // function to filter out some signatures before fetching of real data starts. For example\n      // we want to disable of loading some IDs\n      filterSignature: sig => sig\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    //global flag telling us that we should stop polling.\n    this.endReached = false\n\n    //main functions from params\n    this.createSignatureRequest = createSignatureRequest\n    this.createContentItemRequest = createContentItemRequest\n    this.sortingFunction = sortingFunction\n\n    //collection of just IDs and fields by which content is sorted\n    this.contentSignaturesPool = []\n  }\n\n  async loadNext (customLoadNumber = false) {\n    // if poll is empty and end is not reached (means this is first calling of loadNext) -\n    // get those signatures!\n    if (!this.contentSignaturesPool.length && !this.endReached) {\n      this.contentSignaturesPool = await this.getSignatures()\n    }\n\n    // as long as pool has data - slice in targetCount/customLoadNumber and get individual items\n    if (this.contentSignaturesPool.length) {\n      const contentToRequest = this.contentSignaturesPool.splice(0, customLoadNumber || this.options.targetCount)\n\n      // but if this was the last slice - flag the \"endReached\"\n      if (!this.contentSignaturesPool.length) {\n        this.endReached = true\n      }\n\n      const contentsResponse = await promiseRestBatch(contentToRequest, (entry, eI, rI) => {\n        return {\n          key: rI + '.' + eI,\n          request: {\n            method: 'GET',\n            endpoint: this.createContentItemRequest(entry)\n          }\n        }\n      })\n\n      //todo: figure out what to do with errors inside this list (now they're just ignored)\n      return {\n        list: contentsResponse\n          .filter(item => !item.error)\n          .map(item => item.data),\n        reason: this.endReached ? 'source ended' : 'reached target count'\n      }\n    } else {\n      return {\n        list: [],\n        reason: 'polling finished'\n      }\n    }\n  }\n\n  async getSignatures () {\n    const {\n      batchNumber,\n      filterSignature\n    } = this.options\n\n    const batchArray = []\n    for (let i = 0; i < batchNumber; i++) batchArray.push(i)\n\n    const response = await promiseRestBatch(batchArray, (batchPageIndex, entryIndex, requestIndex) => {\n      return {\n        key: requestIndex + '.' + entryIndex,\n        request: {\n          method: 'GET',\n          endpoint: this.createSignatureRequest(batchPageIndex)\n        }\n      }\n    }, {\n      maxEntries: this.options.batchMaxEntries,\n      shouldBatchContinue: this.options.shouldBatchContinue\n    })\n\n    //todo: figure out what to do with errors inside this list (now they're just ignored)\n    const signatures = response\n      .filter(chunk => chunk.status === 200)\n      .map(chunk => chunk.data.list)\n      .reduce((accum, current) => accum.concat(current), [])\n      .filter(sig => filterSignature(sig))\n\n    const sortedSignatures = signatures.sort(this.sortingFunction)\n\n    console.log('response', response)\n    console.log('sortedSignatures', sortedSignatures)\n\n    return sortedSignatures\n  }\n}\n"]}