{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","getNextAsyncFunc","getError","getList","resultPool","endReached","resolve","reject","loadCount","_log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","_recursiveLoad","loadOptions","log","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","loose","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAEA;;;;IAIaA,gB,WAAAA,gB;;;;;AAEX;6BACUC,qB,EAAuB;AAC/B,aAAOA,sBAAsBC,KAAtB,IAA+B,KAAtC;AACD;;AAED;;;;4BACSD,qB,EAAuB;AAC9B,aAAOA,sBAAsBE,IAAtB,IAA8B,EAArC;AACD;;AAED;;;;;;;;;qCAMkBF,qB,EAAuB;AACvCG,cAAQC,IAAR,CAAa,qEAAb;AACA,aAAO,KAAP;AACD;;AAED;;;;;;;;;AAMA,4BAAaC,aAAb,EAA4BC,MAA5B,EAAkD;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAAA;;;AAEhD,QAAMC,kBAAkB;AACtBC,aAAO,KADe;AAEtBC,mBAAa,EAFS;AAGtBC,uBAAiB,CAHK;AAItBC,wBAAoB,KAAKA,gBAAzB,MAAoB,IAApB,CAJsB;AAKtBC,gBAAY,KAAKA,QAAjB,MAAY,IAAZ,CALsB;AAMtBC,eAAW,KAAKA,OAAhB,MAAW,IAAX;AANsB,KAAxB;;AASA,SAAKP,OAAL,8BAAoBC,eAApB,EAAwCD,OAAxC;;AAEA,SAAKF,aAAL,GAAqBA,aAArB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKS,UAAL,GAAkB,EAAlB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACD;;;;;2GAEqBC,O,EAASC,M,EAAQC,S;;;;;;;;;uBAEC,KAAKd,aAAL,E;;;AAA9BL,qC;2BAQF,KAAKO,O,EALPM,Q,YAAAA,Q,EACAC,O,YAAAA,O,EACAF,gB,YAAAA,gB,EACAF,W,YAAAA,W,EACAC,e,YAAAA,e;;;AAGF,qBAAKS,IAAL,CAAU,uBAAV,EAAmCpB,qBAAnC;;AAEA;AACMC,qB,GAAQY,SAASb,qBAAT,C;;qBACVC,K;;;;;sBAAa,IAAIoB,KAAJ,CAAUpB,KAAV,C;;;;AAEjB;AACIC,oB,GAAOY,QAAQd,qBAAR,C;;AAEX;AACA;AACA;;oBACKE,KAAKoB,M;;;;;AACR,qBAAKF,IAAL,CAAU,2CAAV;AACA,qBAAKJ,UAAL,GAAkB,IAAlB;AACAC,wBAAQ;AACNf,wBAAM,KAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,CADA;AAENC,0BAAQ;AAFF,iBAAR;iDAIO,I;;;;uBAIkB,KAAKlB,MAAL,CAAYJ,IAAZ,6CAAsB,KAAKa,UAA3B,G;;;AAArBU,4B;;;AAEN,qBAAKV,UAAL,GAAkB,KAAKA,UAAL,CAAgBW,MAAhB,CAAuBD,YAAvB,CAAlB;;AAEA;AACA;AACME,6B,GAAgBf,iBAAiBZ,qBAAjB,C;;AACtB,oBAAI,OAAO2B,aAAP,KAAyB,UAA7B,EAAyC;AACvC,uBAAKtB,aAAL,GAAqBsB,aAArB;AACD,iBAFD,MAEO;AACL,uBAAKX,UAAL,GAAkB,IAAlB;AACD;;AAED;;sBACI,KAAKD,UAAL,CAAgBO,MAAhB,IAA0BZ,W;;;;;AAC5B,qBAAKU,IAAL,CAAU,2CAAV;AACAH,wBAAQ;AACNf,wBAAM,KAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,EAA0Bb,WAA1B,CADA;AAENc,0BAAQ;AAFF,iBAAR;AAIA,qBAAKJ,IAAL,CAAU,gBAAV,EAA4B,KAAKL,UAAjC;iDACO,I;;;;AAGTI;;sBAEIR,kBAAkB,CAAlB,IAAuBQ,aAAaR,e;;;;;AACtC;AACA;AACA,qBAAKS,IAAL,CAAU,mDAAV;AACAH,wBAAQ;AACNf,wBAAM,KAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,CADA;AAENC,0BAAQ;AAFF,iBAAR;iDAIO,I;;;oBAEG,KAAKR,U;;;;;AACf;AACA,qBAAKI,IAAL,CAAU,KAAV,EAAiB,KAAKL,UAAL,CAAgBO,MAAjC,EAAyC,iBAAzC,EAA4DZ,WAA5D,EAAyE,4BAAzE;AACA,qBAAKkB,cAAL,CAAoBX,OAApB,EAA6BC,MAA7B,EAAqCC,SAArC;iDACO,I;;;AAGP,qBAAKC,IAAL,CAAU,2CAAV;AACAH,wBAAQ;AACNf,wBAAM,KAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,CADA;AAENC,0BAAQ;AAFF,iBAAR;;;;;;;;;;AAOFN;;;;;;;;;;;;;;;;;;6BAIMW,W,EAAa;AAAA;;AACrB,aAAO,sBAAY,UAACZ,OAAD,EAAUC,MAAV,EAAqB;AAAA,YAE9BR,WAF8B,GAEd,MAAKH,OAFS,CAE9BG,WAF8B;;;AAItC,YAAI,MAAKK,UAAL,CAAgBO,MAAhB,IAA0BZ,WAA9B,EAA2C;AACzC,gBAAKU,IAAL,CAAU,qCAAV;AACAH,kBAAQ;AACNf,kBAAM,MAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,EAA0Bb,WAA1B,CADA;AAENc,oBAAQ;AAFF,WAAR;AAIA,iBAAO,IAAP;AACD;;AAED,YAAI,MAAKR,UAAT,EAAqB;AACnB,cAAI,MAAKD,UAAL,CAAgBO,MAApB,EAA4B;AAC1B,kBAAKF,IAAL,CAAU,2CAAV;AACAH,oBAAQ;AACNf,oBAAM,MAAKa,UAAL,CAAgBQ,MAAhB,CAAuB,CAAvB,CADA;AAENC,sBAAQ;AAFF,aAAR;AAID,WAND,MAMO;AACL,kBAAKJ,IAAL,CAAU,iDAAV;AACAH,oBAAQ;AACNf,oBAAM,EADA;AAENsB,sBAAQ;AAFF,aAAR;AAID;AACD,iBAAO,IAAP;AACD;;AAED,cAAKI,cAAL,CAAoBX,OAApB,EAA6BC,MAA7B,EAAqC,CAArC;AACD,OA/BM,CAAP;AAgCD;;;2BAEc;AACb,UAAI,KAAKX,OAAL,CAAaE,KAAjB,EAAwB;AAAA;;AACtB,6BAAQqB,GAAR;AACD;AACF;;;;;IAGUC,sB,WAAAA,sB;;;;4BACF/B,qB,EAAuB;AAC9B;AACA,UAAMgC,kBAAkBhC,sBAAsBiC,OAAtB,IAAiCjC,qBAAzD;AACA,aAAOgC,gBAAgB9B,IAAhB,IAAwB,EAA/B;AACD;;;6BAESF,qB,EAAuB;AAC/B;AACA,UAAIA,sBAAsBkC,MAA1B,EAAkC;AAChC,gBAAQlC,sBAAsBkC,MAA9B;AACE,eAAK,GAAL;AACE,mBAAO,KAAP;AACF,eAAK,GAAL;AACE,mBAAO,iBAAP;AACF;AACE,mBAAOlC,sBAAsBkC,MAA7B;AANJ;AAQD;;AAED,aAAO,KAAP;AACD;;;qCAEiBlC,qB,EAAuB;AACvC,UAAMgC,kBAAkBhC,sBAAsBiC,OAAtB,IAAiCjC,qBAAzD;;AADuC,UAG/BmC,YAH+B,GAGDH,eAHC,CAG/BG,YAH+B;AAAA,UAGjBjC,IAHiB,GAGD8B,eAHC,CAGjB9B,IAHiB;AAAA,UAGXkC,KAHW,GAGDJ,eAHC,CAGXI,KAHW;;;AAKvC,UACE,CAACJ,gBAAgBI,KAAjB,IACG,CAACJ,gBAAgBI,KAAhB,CAAsBC,IAD1B,IAEInC,KAAKoB,MAAL,GAAca,YAAd,IAA8B,CAAC,KAAK5B,OAAL,CAAa+B,KAHlD,EAIE;AACA;AACA,eAAO,KAAP;AACD;;AAED,aAAO,KAAK/B,OAAL,CAAagC,mBAAb,CAAiCH,MAAMC,IAAvC,EAA6CL,eAA7C,CAAP;AACD;;;wCAEoBQ,Q,EAAUR,e,EAAiB;AAAA;;AAC9C,aAAO,YAAM;AACX,YAAMS,OAAOD,SAASE,KAAT,CAAe,aAAf,EAA8B,CAA9B,CAAb;AACA,YAAI,OAAKnC,OAAL,CAAaoC,MAAb,CAAoBC,WAApB,OAAsC,KAA1C,EAAiD,OAAO,kCAAeH,IAAf,CAAP;AACjD,YAAI,OAAKlC,OAAL,CAAaoC,MAAb,CAAoBC,WAApB,OAAsC,MAA1C,EAAkD,OAAO,mCAAgBH,IAAhB,CAAP;AACnD,OAJD;AAKD;;;AAED,kCAAapC,aAAb,EAA4BC,MAA5B,EAAkD;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AAAA;;AAAA,uKAC1CF,aAD0C,EAC3BC,MAD2B,EACnBC,OADmB;;AAGhD,QAAMC,kBAAkB;AACtB;AACA;AACA8B,aAAO,KAHe;AAItBK,cAAQ,KAJc;AAKtBJ,2BAAuB,OAAKA,mBAA5B;AALsB,KAAxB;;AAQA,WAAKhC,OAAL,8BAAoBC,eAApB,EAAwC,OAAKD,OAA7C,EAAyDA,OAAzD;AAXgD;AAYjD;;;EA5DyCR,gB;;IA+D/B8C,uB,WAAAA,uB;;;;;;;;;;4BACF7C,qB,EAAuB;AAC9B;AACA,UAAMgC,kBAAkBhC,sBAAsBiC,OAAtB,IAAiCjC,qBAAzD;AACA,aAAOgC,gBAAgB9B,IAAhB,IAAwB,EAA/B;AACD;;;qCAEiBF,qB,EAAuB;AACvC,UAAI,OAAOA,sBAAsB8C,WAA7B,KAA6C,UAAjD,EAA6D;AAC3D,eAAO;AAAA,iBAAM,uCAAoB9C,sBAAsB8C,WAA1C,CAAN;AAAA,SAAP;AACD;;AAED,aAAO,KAAP;AACD;;;EAb0C/C,gB;;kBAgB9B;AACbA,oCADa;AAEbgC,gDAFa;AAGbc;AAHa,C","file":"ContinuousLoader.js","sourcesContent":["import { promiseOsapiRequest, promiseRestGet, promiseRestPost } from './fetchPromise'\n\n/*\n * Continuous loader designed to abstract loading content lists by any asynchronous API in cases\n * when said API doesn't support filtering parameters by which you want to filter this content.\n */\nexport class ContinuousLoader {\n\n  // Overrideable method that gets error from API response\n  getError (asyncFunctionResponse) {\n    return asyncFunctionResponse.error || false\n  }\n\n  // Overrideable method that gets content list from API response\n  getList (asyncFunctionResponse) {\n    return asyncFunctionResponse.list || []\n  }\n\n  /**\n   * Overrideable method to create new promise-returning function\n   * @param asyncFunctionResponse\n   * @returns {function|boolean} - should return async function (one that returns promise),\n   * NOT promise itself\n   */\n  getNextAsyncFunc (asyncFunctionResponse) {\n    console.warn('getNextAsyncFunc should be defined in either options or child class')\n    return false\n  }\n\n  /**\n   * Constructs a class instance\n   * @param {function} asyncFunction - should return Promise\n   * @param {function} filter - should return array\n   * @param {object} [options]\n   */\n  constructor (asyncFunction, filter, options = {}) {\n\n    const optionsDefaults = {\n      debug: false,\n      targetCount: 10,\n      maxTriesPerLoad: 5,\n      getNextAsyncFunc: ::this.getNextAsyncFunc,\n      getError: ::this.getError,\n      getList: ::this.getList\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    this.asyncFunction = asyncFunction\n    this.filter = filter\n    this.resultPool = []\n    this.endReached = false\n  }\n\n  async _recursiveLoad (resolve, reject, loadCount) {\n    try {\n      const asyncFunctionResponse = await this.asyncFunction()\n\n      const {\n        getError,\n        getList,\n        getNextAsyncFunc,\n        targetCount,\n        maxTriesPerLoad\n      } = this.options\n\n      this._log('asyncFunctionResponse', asyncFunctionResponse)\n\n      // catch errors\n      const error = getError(asyncFunctionResponse)\n      if (error) throw new Error(error)\n\n      //getting list\n      let list = getList(asyncFunctionResponse)\n\n      //if unfiltered list is empty - means nothing to load\n      // returning the rest of result poll (if any) and blocking\n      // further calls of this.loadNext\n      if (!list.length) {\n        this._log('zero items get, returning []/rest of pool')\n        this.endReached = true\n        resolve({\n          list: this.resultPool.splice(0),\n          reason: 'source ended'\n        })\n        return null\n      }\n\n      //put (mapped and) filtered items in pool\n      const filteredList = await this.filter(list, [...this.resultPool])\n\n      this.resultPool = this.resultPool.concat(filteredList)\n\n      // getting possible next poll - this should be done before first possible\n      // contentful resolve()\n      const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n      if (typeof nextAsyncFunc === 'function') {\n        this.asyncFunction = nextAsyncFunc\n      } else {\n        this.endReached = true\n      }\n\n      //if pool reached target number - resolve items and remove them from pool\n      if (this.resultPool.length >= targetCount) {\n        this._log('pool reached the target count. set pause.')\n        resolve({\n          list: this.resultPool.splice(0, targetCount),\n          reason: 'reached target count'\n        })\n        this._log('(rest of pool:', this.resultPool)\n        return null\n      }\n\n      loadCount++\n\n      if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad) {\n        // if pool hasn't reached the target number, but it's last poll according to\n        // maxTriesPerLoad\n        this._log('max tries reached. returning what\\'s found so far')\n        resolve({\n          list: this.resultPool.splice(0),\n          reason: 'max polls reached'\n        })\n        return null\n\n      } else if (!this.endReached) {\n        //if pool hasn't reached target number, but there's more to load\n        this._log('got', this.resultPool.length, 'while target is', targetCount, 'need to load one more time')\n        this._recursiveLoad(resolve, reject, loadCount)\n        return null\n\n      } else {\n        this._log('no next promise available. returning pool')\n        resolve({\n          list: this.resultPool.splice(0),\n          reason: 'source ended'\n        })\n      }\n\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  loadNext (loadOptions) {\n    return new Promise((resolve, reject) => {\n\n      const { targetCount } = this.options\n\n      if (this.resultPool.length >= targetCount) {\n        this._log('target count found in existing pool')\n        resolve({\n          list: this.resultPool.splice(0, targetCount),\n          reason: 'target count exists in pool'\n        })\n        return null\n      }\n\n      if (this.endReached) {\n        if (this.resultPool.length) {\n          this._log('no next promise available. returning pool')\n          resolve({\n            list: this.resultPool.splice(0),\n            reason: 'source ended'\n          })\n        } else {\n          this._log('end was already reached before, no more polling')\n          resolve({\n            list: [],\n            reason: 'polling finished'\n          })\n        }\n        return null\n      }\n\n      this._recursiveLoad(resolve, reject, 0)\n    })\n  }\n\n  _log (...args) {\n    if (this.options.debug) {\n      console.log(...args)\n    }\n  }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //this._log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getError (asyncFunctionResponse) {\n    //this._log('REST getError')\n    if (asyncFunctionResponse.status) {\n      switch (asyncFunctionResponse.status) {\n        case 200:\n          return false\n        case 204:\n          return '204: No Content'\n        default:\n          return asyncFunctionResponse.status\n      }\n    }\n\n    return false\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n    const { itemsPerPage, list, links } = responseContent\n\n    if (\n      !responseContent.links\n      || !responseContent.links.next\n      || (list.length < itemsPerPage && !this.options.loose)\n    ) {\n      // there's nothing to load more\n      return false\n    }\n\n    return this.options.createNextAsyncFunc(links.next, responseContent)\n  }\n\n  createNextAsyncFunc (nextLink, responseContent) {\n    return () => {\n      const link = nextLink.split('api/core/v3')[1]\n      if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n      if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n    }\n  }\n\n  constructor (asyncFunction, filter, options = {}) {\n    super(asyncFunction, filter, options)\n\n    const optionsDefaults = {\n      // loose:true means that (list.length < itemsPerPage) doesn't mean list has ended.\n      // Useful for jive REST \"/activity\" endpoint\n      loose: false,\n      method: 'get',\n      createNextAsyncFunc: ::this.createNextAsyncFunc\n    }\n\n    this.options = { ...optionsDefaults, ...this.options, ...options }\n  }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //console.log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    if (typeof asyncFunctionResponse.getNextPage === 'function') {\n      return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n    }\n\n    return false\n  }\n}\n\nexport default {\n  ContinuousLoader,\n  ContinuousLoadJiveREST,\n  ContinuousLoadJiveOSAPI\n}"]}