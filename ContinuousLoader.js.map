{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","timeLimit","getNextAsyncFunc","getError","getList","transformResponse","resultPool","endReached","_transformResponse","resolve","reject","loadCount","_log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","sincePassStart","Date","now","passStartTS","_recursiveLoad","then","catch","log","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","loose","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","file":"ContinuousLoader.js","sourcesContent":["import { promiseOsapiRequest, promiseRestGet, promiseRestPost } from './fetchPromise'\n\n/*\n * Continuous loader designed to abstract loading content lists by any asynchronous API in cases\n * when said API doesn't support filtering parameters by which you want to filter this content.\n */\nexport class ContinuousLoader {\n\n  // Overrideable method that gets error from API response\n  getError (asyncFunctionResponse) {\n    return asyncFunctionResponse.error || false\n  }\n\n  // Overrideable method that gets content list from API response\n  getList (asyncFunctionResponse) {\n    return asyncFunctionResponse.list || []\n  }\n\n  /**\n   * Overrideable method to create new promise-returning function\n   * @param asyncFunctionResponse\n   * @returns {function|boolean} - should return async function (one that returns promise),\n   * NOT promise itself\n   */\n  getNextAsyncFunc (asyncFunctionResponse) {\n    console.warn('getNextAsyncFunc should be defined in either options or child class')\n    return false\n  }\n\n  /**\n   * Constructs a class instance\n   * @param {function} asyncFunction - should return Promise\n   * @param {function} filter - should return array\n   * @param {object} [options]\n   */\n  constructor (asyncFunction, filter, options = {}) {\n\n    const optionsDefaults = {\n      debug: false,\n      targetCount: 10,\n      maxTriesPerLoad: 5,\n      timeLimit: 10000,\n      getNextAsyncFunc: ::this.getNextAsyncFunc,\n      getError: ::this.getError,\n      getList: ::this.getList,\n      transformResponse: null\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    this.asyncFunction = asyncFunction\n    this.filter = filter\n    this.resultPool = []\n    this.endReached = false\n    this.transformResponse = this.options.transformResponse || ::this._transformResponse\n  }\n\n  _transformResponse (list) {\n    return  Promise.resolve(list)\n  }\n\n  async _recursiveLoad (resolve, reject, loadCount) {\n    try {\n      const asyncFunctionResponse = await this.asyncFunction()\n\n      const {\n        getError,\n        getList,\n        getNextAsyncFunc,\n        targetCount,\n        maxTriesPerLoad\n      } = this.options\n\n      this._log('asyncFunctionResponse', asyncFunctionResponse)\n\n      // catch errors\n      const error = getError(asyncFunctionResponse)\n      if (error) throw new Error(error)\n\n      //getting list\n      let list = getList(asyncFunctionResponse)\n\n      //if unfiltered list is empty - means nothing to load\n      // returning the rest of result poll (if any) and blocking\n      // further calls of this.loadNext\n      if (!list.length) {\n        this._log('zero items get, returning []/rest of pool')\n        this.endReached = true\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n        return null\n      }\n\n      //put (mapped and) filtered items in pool\n      const filteredList = await this.filter(list, [...this.resultPool])\n\n      this.resultPool = this.resultPool.concat(filteredList)\n\n      // getting possible next poll - this should be done before first possible\n      // contentful resolve()\n      const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n      if (typeof nextAsyncFunc === 'function') {\n        this.asyncFunction = nextAsyncFunc\n      } else {\n        this.endReached = true\n      }\n\n      //if pool reached target number - resolve items and remove them from pool\n      if (this.resultPool.length >= targetCount) {\n        this._log('pool reached the target count. set pause.')\n\n        const list = await this.transformResponse(this.resultPool.splice(0, targetCount))\n\n        resolve({ list, reason: 'reached target count' })\n        this._log('(rest of pool:', this.resultPool)\n        return null\n      }\n\n      loadCount++\n      const sincePassStart = Date.now() - this.passStartTS\n      this._log('Time passes since pass started', sincePassStart)\n\n      if (sincePassStart > this.options.timeLimit) {\n        // if pool hasn't reached the target number, but time limit has been exceded\n        this._log('time limit of ' + this.options.timeLimit + 'ms is exceeded. returning what\\'s' +\n          ' found so far')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'time limit exceeded' })\n        return null\n      } else if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad) {\n        // if pool hasn't reached the target number, but it's last poll according to\n        // maxTriesPerLoad\n        this._log('max tries reached. returning what\\'s found so far')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'max polls reached' })\n        return null\n\n      } else if (!this.endReached) {\n        //if pool hasn't reached target number, but there's more to load\n        this._log('got', this.resultPool.length, 'while target is', targetCount, 'need to load one more time')\n        this._recursiveLoad(resolve, reject, loadCount)\n        return null\n\n      } else {\n        this._log('no next promise available. returning pool')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n      }\n\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  loadNext () {\n    return new Promise((resolve, reject) => {\n      const { targetCount } = this.options\n\n      if (this.resultPool.length >= targetCount) {\n        this._log('target count found in existing pool')\n\n        this.transformResponse(this.resultPool.splice(0, targetCount))\n          .then(list => resolve({ list, reason: 'target count exists in pool' }))\n          .catch(reject)\n\n        return null\n      }\n\n      if (this.endReached) {\n        if (this.resultPool.length) {\n          this._log('no next promise available. returning pool')\n          this.transformResponse(this.resultPool.splice(0))\n            .then(list => resolve({ list, reason: 'source ended' }))\n            .catch(reject)\n        } else {\n          this._log('end was already reached before, no more polling')\n          resolve({\n            list: [],\n            reason: 'polling finished'\n          })\n        }\n        return null\n      }\n\n      this.passStartTS = Date.now()\n      this._recursiveLoad(resolve, reject, 0)\n    })\n  }\n\n  _log (...args) {\n    if (this.options.debug) {\n      console.log(...args)\n    }\n  }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //this._log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getError (asyncFunctionResponse) {\n    //this._log('REST getError')\n    if (asyncFunctionResponse.status) {\n      switch (asyncFunctionResponse.status) {\n        case 200:\n          return false\n        case 204:\n          return '204: No Content'\n        default:\n          return asyncFunctionResponse.status\n      }\n    }\n\n    return false\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n    const { itemsPerPage, list, links } = responseContent\n\n    if (\n      !responseContent.links\n      || !responseContent.links.next\n      || (list.length < itemsPerPage && !this.options.loose)\n    ) {\n      // there's nothing to load more\n      return false\n    }\n\n    return this.options.createNextAsyncFunc(links.next, responseContent)\n  }\n\n  createNextAsyncFunc (nextLink, responseContent) {\n    return () => {\n      const link = nextLink.split('api/core/v3')[1]\n      if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n      if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n    }\n  }\n\n  constructor (asyncFunction, filter, options = {}) {\n    super(asyncFunction, filter, options)\n\n    const optionsDefaults = {\n      // loose:true means that (list.length < itemsPerPage) doesn't mean list has ended.\n      // Useful for jive REST \"/activity\" endpoint\n      loose: false,\n      method: 'get',\n      createNextAsyncFunc: ::this.createNextAsyncFunc\n    }\n\n    this.options = { ...optionsDefaults, ...this.options, ...options }\n  }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //console.log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    if (typeof asyncFunctionResponse.getNextPage === 'function') {\n      return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n    }\n\n    return false\n  }\n}\n\nexport default {\n  ContinuousLoader,\n  ContinuousLoadJiveREST,\n  ContinuousLoadJiveOSAPI\n}"]}