{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","getNextAsyncFunc","getError","getList","resultPool","endReached","resolve","reject","loadCount","_log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","_recursiveLoad","log","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","loose","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","file":"ContinuousLoader.js","sourcesContent":["import {promiseOsapiRequest, promiseRestPost, promiseRestGet} from './fetchPromise'\n\nexport class ContinuousLoader {\n\n    getError(asyncFunctionResponse) {\n        return asyncFunctionResponse.error || false\n    }\n\n    getList (asyncFunctionResponse) {\n        return asyncFunctionResponse.list || []\n    }\n\n    /**\n     * Overrideable function to create new promise-returning function\n     * @param asyncFunctionResponse\n     * @returns {function|boolean} - should return async function (one that returns promise),\n     * NOT promise itself\n     */\n    getNextAsyncFunc(asyncFunctionResponse){\n        console.warn('getNextAsyncFunc should be defined in either options or child class')\n        return false\n    }\n\n    /**\n     * Constructs a class instance\n     * @param {function} asyncFunction - should return Promise\n     * @param {function} filter - should return array\n     * @param {object} [options]\n     */\n    constructor(asyncFunction, filter, options = {}) {\n\n        const optionsDefaults = {\n            debug: false,\n            targetCount: 10,\n            maxTriesPerLoad: 5,\n            getNextAsyncFunc: ::this.getNextAsyncFunc,\n            getError: ::this.getError,\n            getList: ::this.getList\n        }\n\n        this.options = {...optionsDefaults, ...options}\n\n        this.asyncFunction = asyncFunction\n        this.filter = filter\n        this.resultPool = []\n        this.endReached = false\n    }\n\n    async _recursiveLoad(resolve, reject, loadCount){\n        try {\n            const asyncFunctionResponse = await this.asyncFunction()\n\n            const {\n                getError,\n                getList,\n                getNextAsyncFunc,\n                targetCount,\n                maxTriesPerLoad\n            } = this.options\n\n            this._log('asyncFunctionResponse', asyncFunctionResponse)\n\n            // catch errors\n            const error = getError(asyncFunctionResponse)\n            if (error) throw new Error(error)\n\n            //getting list\n            let list = getList(asyncFunctionResponse)\n\n            //if unfiltered list is empty - means nothing to load\n            // returning the rest of result poll (if any) and blocking\n            // further calls of this.loadNext\n            if (!list.length) {\n                this._log('zero items get, returning []/rest of pool')\n                this.endReached = true\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n                return null\n            }\n\n            //put (mapped and) filtered items in pool\n            const filteredList = await this.filter(list, [...this.resultPool])\n\n            this.resultPool = this.resultPool.concat(filteredList)\n\n            // getting possible next poll - this should be done before first possible\n            // contentful resolve()\n            const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n            if (typeof nextAsyncFunc === 'function'){\n                this.asyncFunction = nextAsyncFunc\n            } else {\n                this.endReached = true\n            }\n\n            //if pool reached target number - resolve items and remove them from pool\n            if (this.resultPool.length >= targetCount) {\n                this._log('pool reached the target count. set pause.')\n                resolve({\n                    list: this.resultPool.splice(0, targetCount),\n                    reason: 'reached target count'\n                })\n                this._log('(rest of pool:', this.resultPool)\n                return null\n            }\n\n            loadCount++\n\n            if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad){\n                // if pool hasn't reached the target number, but it's last poll according to\n                // maxTriesPerLoad\n                this._log(\"max tries reached. returning what's found so far\")\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'max polls reached'\n                })\n                return null\n\n            } else if (!this.endReached) {\n                //if pool hasn't reached target number, but there's more to load\n                this._log('got', this.resultPool.length, 'while target is', targetCount ,'need to load one more time')\n                this._recursiveLoad(resolve, reject, loadCount)\n                return null\n\n            } else {\n                this._log('no next promise available. returning pool')\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n            }\n\n        } catch (error) {\n            reject(error)\n        }\n    }\n\n    loadNext() {\n        return new Promise((resolve, reject) => {\n\n            const {targetCount} = this.options\n\n            if (this.resultPool.length >= targetCount) {\n                this._log('target count found in existing pool')\n                resolve({\n                    list: this.resultPool.splice(0, targetCount),\n                    reason: 'target count exists in pool'\n                })\n                return null\n            }\n\n            if (this.endReached) {\n                if (this.resultPool.length) {\n                    this._log('no next promise available. returning pool')\n                    resolve({\n                        list: this.resultPool.splice(0),\n                        reason: 'source ended'\n                    })\n                } else {\n                    this._log('end was already reached before, no more polling')\n                    resolve({\n                        list: [],\n                        reason: 'polling finished'\n                    })\n                }\n                return null\n            }\n\n            this._recursiveLoad(resolve, reject, 0)\n        })\n    }\n\n    _log(...args){\n        if (this.options.debug){\n            console.log(...args)\n        }\n    }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //this._log('REST getList')\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n        return  responseContent.list || []\n    }\n\n    getError(asyncFunctionResponse) {\n        //this._log('REST getError')\n        if (asyncFunctionResponse.status) {\n            switch (asyncFunctionResponse.status) {\n                case 200:\n                    return false\n                case 204:\n                    return '204: No Content'\n                default:\n                    return asyncFunctionResponse.status\n            }\n        }\n\n        return false\n    }\n\n    getNextAsyncFunc (asyncFunctionResponse){\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n        const {itemsPerPage, list, links} = responseContent\n\n        if (\n            !responseContent.links\n            || !responseContent.links.next\n            || (list.length < itemsPerPage && !this.options.loose)\n        ) {\n            // there's nothing to load more\n            return false\n        }\n\n        return this.options.createNextAsyncFunc(links.next, responseContent)\n    }\n\n    createNextAsyncFunc(nextLink, responseContent){\n        return () => {\n            const link = nextLink.split('api/core/v3')[1]\n            if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n            if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n        }\n    }\n\n    constructor(asyncFunction, filter, options = {}){\n        super(asyncFunction, filter, options)\n\n        const optionsDefaults = {\n            // loose:true means that (list.length < itemsPerPage) doesn't mean list has ended.\n            // Useful for /activity andpoint\n            loose: false,\n            method: 'get',\n            createNextAsyncFunc: ::this.createNextAsyncFunc\n        }\n\n        this.options = {...optionsDefaults, ...this.options, ...options}\n    }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //console.log('REST getList')\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n        return  responseContent.list || []\n    }\n\n    getNextAsyncFunc(asyncFunctionResponse){\n        if (typeof asyncFunctionResponse.getNextPage === 'function'){\n            return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n        }\n\n        return false\n    }\n}\n\nexport default {\n    ContinuousLoader,\n    ContinuousLoadJiveREST,\n    ContinuousLoadJiveOSAPI\n}"]}