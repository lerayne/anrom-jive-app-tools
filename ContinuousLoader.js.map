{"version":3,"sources":["ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","timeLimit","getNextAsyncFunc","bind","getError","getList","transformResponse","resultPool","endReached","_transformResponse","asyncFunctionResponse","error","list","console","warn","Promise","resolve","reject","loadCount","_log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","sincePassStart","Date","now","passStartTS","_recursiveLoad","then","log","ContinuousLoadJiveREST","loose","method","createNextAsyncFunc","responseContent","content","status","itemsPerPage","links","next","nextLink","link","split","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","sourcesContent":["import { promiseOsapiRequest, promiseRestGet, promiseRestPost } from './fetchPromise'\n\n/*\n * Continuous loader designed to abstract loading content lists by any asynchronous API in cases\n * when said API doesn't support filtering parameters by which you want to filter this content.\n */\nexport class ContinuousLoader {\n\n  // Overrideable method that gets error from API response\n  getError (asyncFunctionResponse) {\n    return asyncFunctionResponse.error || false\n  }\n\n  // Overrideable method that gets content list from API response\n  getList (asyncFunctionResponse) {\n    return asyncFunctionResponse.list || []\n  }\n\n  /**\n   * Overrideable method to create new promise-returning function\n   * @param asyncFunctionResponse\n   * @returns {function|boolean} - should return async function (one that returns promise),\n   * NOT promise itself\n   */\n  getNextAsyncFunc (asyncFunctionResponse) {\n    console.warn('getNextAsyncFunc should be defined in either options or child class')\n    return false\n  }\n\n  /**\n   * Constructs a class instance\n   * @param {function} asyncFunction - should return Promise\n   * @param {function} filter - should return array\n   * @param {object} [options]\n   */\n  constructor (asyncFunction, filter, options = {}) {\n\n    const optionsDefaults = {\n      debug: false,\n      targetCount: 10,\n      maxTriesPerLoad: 5,\n      timeLimit: 10000,\n      getNextAsyncFunc: this.getNextAsyncFunc.bind(this),\n      getError: this.getError.bind(this),\n      getList: this.getList.bind(this),\n      transformResponse: null\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    this.asyncFunction = asyncFunction\n    this.filter = filter\n    this.resultPool = []\n    this.endReached = false\n    this.transformResponse = this.options.transformResponse || this._transformResponse.bind(this)\n  }\n\n  _transformResponse (list) {\n    return  Promise.resolve(list)\n  }\n\n  async _recursiveLoad (resolve, reject, loadCount) {\n    try {\n      const asyncFunctionResponse = await this.asyncFunction()\n\n      const {\n        getError,\n        getList,\n        getNextAsyncFunc,\n        targetCount,\n        maxTriesPerLoad\n      } = this.options\n\n      this._log('asyncFunctionResponse', asyncFunctionResponse)\n\n      // catch errors\n      const error = getError(asyncFunctionResponse)\n      if (error) throw new Error(error)\n\n      //getting list\n      let list = getList(asyncFunctionResponse)\n\n      //if unfiltered list is empty - means nothing to load\n      // returning the rest of result poll (if any) and blocking\n      // further calls of this.loadNext\n      if (!list.length) {\n        this._log('zero items get, returning []/rest of pool')\n        this.endReached = true\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n        return null\n      }\n\n      //put (mapped and) filtered items in pool\n      const filteredList = await this.filter(list, [...this.resultPool])\n\n      this.resultPool = this.resultPool.concat(filteredList)\n\n      // getting possible next poll - this should be done before first possible\n      // contentful resolve()\n      const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n      if (typeof nextAsyncFunc === 'function') {\n        this.asyncFunction = nextAsyncFunc\n      } else {\n        this.endReached = true\n      }\n\n      //if pool reached target number - resolve items and remove them from pool\n      if (this.resultPool.length >= targetCount) {\n        this._log('pool reached the target count. set pause.')\n\n        const list = await this.transformResponse(this.resultPool.splice(0, targetCount))\n\n        resolve({ list, reason: 'reached target count' })\n        this._log('(rest of pool:', this.resultPool)\n        return null\n      }\n\n      loadCount++\n      const sincePassStart = Date.now() - this.passStartTS\n      this._log('Time passes since pass started', sincePassStart)\n\n      if (sincePassStart > this.options.timeLimit) {\n        // if pool hasn't reached the target number, but time limit has been exceded\n        this._log('time limit of ' + this.options.timeLimit + 'ms is exceeded. returning what\\'s' +\n          ' found so far')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'time limit exceeded' })\n        return null\n      } else if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad) {\n        // if pool hasn't reached the target number, but it's last poll according to\n        // maxTriesPerLoad\n        this._log('max tries reached. returning what\\'s found so far')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'max polls reached' })\n        return null\n\n      } else if (!this.endReached) {\n        //if pool hasn't reached target number, but there's more to load\n        this._log('got', this.resultPool.length, 'while target is', targetCount, 'need to load one more time')\n        this._recursiveLoad(resolve, reject, loadCount)\n        return null\n\n      } else {\n        this._log('no next promise available. returning pool')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n      }\n\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  loadNext () {\n    return new Promise((resolve, reject) => {\n      const { targetCount } = this.options\n\n      if (this.resultPool.length >= targetCount) {\n        this._log('target count found in existing pool')\n\n        this.transformResponse(this.resultPool.splice(0, targetCount))\n          .then(list => resolve({ list, reason: 'target count exists in pool' }))\n          .catch(reject)\n\n        return null\n      }\n\n      if (this.endReached) {\n        if (this.resultPool.length) {\n          this._log('no next promise available. returning pool')\n          this.transformResponse(this.resultPool.splice(0))\n            .then(list => resolve({ list, reason: 'source ended' }))\n            .catch(reject)\n        } else {\n          this._log('end was already reached before, no more polling')\n          resolve({\n            list: [],\n            reason: 'polling finished'\n          })\n        }\n        return null\n      }\n\n      this.passStartTS = Date.now()\n      this._recursiveLoad(resolve, reject, 0)\n    })\n  }\n\n  _log (...args) {\n    if (this.options.debug) {\n      console.log(...args)\n    }\n  }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //this._log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getError (asyncFunctionResponse) {\n    //this._log('REST getError')\n    if (asyncFunctionResponse.status) {\n      switch (asyncFunctionResponse.status) {\n        case 200:\n          return false\n        case 204:\n          return '204: No Content'\n        default:\n          return asyncFunctionResponse.status\n      }\n    }\n\n    return false\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n    const { itemsPerPage, list, links } = responseContent\n\n    if (\n      !responseContent.links\n      || !responseContent.links.next\n      || (list.length < itemsPerPage && !this.options.loose)\n    ) {\n      // there's nothing to load more\n      return false\n    }\n\n    return this.options.createNextAsyncFunc(links.next, responseContent)\n  }\n\n  createNextAsyncFunc (nextLink, responseContent) {\n    return () => {\n      const link = nextLink.split('api/core/v3')[1]\n      if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n      if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n    }\n  }\n\n  constructor (asyncFunction, filter, options = {}) {\n    super(asyncFunction, filter, options)\n\n    const optionsDefaults = {\n      // loose:true means that (list.length < itemsPerPage) doesn't mean list has ended.\n      // Useful for jive REST \"/activity\" endpoint\n      loose: false,\n      method: 'get',\n      createNextAsyncFunc: this.createNextAsyncFunc.bind(this)\n    }\n\n    this.options = { ...optionsDefaults, ...this.options, ...options }\n  }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //console.log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    if (typeof asyncFunctionResponse.getNextPage === 'function') {\n      return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n    }\n\n    return false\n  }\n}\n\nexport default {\n  ContinuousLoader,\n  ContinuousLoadJiveREST,\n  ContinuousLoadJiveOSAPI\n}"],"file":"ContinuousLoader.js"}