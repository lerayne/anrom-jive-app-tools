{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","getNextAsyncFunc","getError","getList","transformResponse","resultPool","endReached","_transformResponse","resolve","reject","loadCount","_log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","_recursiveLoad","then","catch","log","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","loose","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","file":"ContinuousLoader.js","sourcesContent":["import { promiseOsapiRequest, promiseRestGet, promiseRestPost } from './fetchPromise'\n\n/*\n * Continuous loader designed to abstract loading content lists by any asynchronous API in cases\n * when said API doesn't support filtering parameters by which you want to filter this content.\n */\nexport class ContinuousLoader {\n\n  // Overrideable method that gets error from API response\n  getError (asyncFunctionResponse) {\n    return asyncFunctionResponse.error || false\n  }\n\n  // Overrideable method that gets content list from API response\n  getList (asyncFunctionResponse) {\n    return asyncFunctionResponse.list || []\n  }\n\n  /**\n   * Overrideable method to create new promise-returning function\n   * @param asyncFunctionResponse\n   * @returns {function|boolean} - should return async function (one that returns promise),\n   * NOT promise itself\n   */\n  getNextAsyncFunc (asyncFunctionResponse) {\n    console.warn('getNextAsyncFunc should be defined in either options or child class')\n    return false\n  }\n\n  /**\n   * Constructs a class instance\n   * @param {function} asyncFunction - should return Promise\n   * @param {function} filter - should return array\n   * @param {object} [options]\n   */\n  constructor (asyncFunction, filter, options = {}) {\n\n    const optionsDefaults = {\n      debug: false,\n      targetCount: 10,\n      maxTriesPerLoad: 5,\n      getNextAsyncFunc: ::this.getNextAsyncFunc,\n      getError: ::this.getError,\n      getList: ::this.getList,\n      transformResponse: null\n    }\n\n    this.options = { ...optionsDefaults, ...options }\n\n    this.asyncFunction = asyncFunction\n    this.filter = filter\n    this.resultPool = []\n    this.endReached = false\n    this.transformResponse = this.options.transformResponse || ::this._transformResponse\n  }\n\n  _transformResponse (list) {\n    return  Promise.resolve(list)\n  }\n\n  async _recursiveLoad (resolve, reject, loadCount) {\n    try {\n      const asyncFunctionResponse = await this.asyncFunction()\n\n      const {\n        getError,\n        getList,\n        getNextAsyncFunc,\n        targetCount,\n        maxTriesPerLoad\n      } = this.options\n\n      this._log('asyncFunctionResponse', asyncFunctionResponse)\n\n      // catch errors\n      const error = getError(asyncFunctionResponse)\n      if (error) throw new Error(error)\n\n      //getting list\n      let list = getList(asyncFunctionResponse)\n\n      //if unfiltered list is empty - means nothing to load\n      // returning the rest of result poll (if any) and blocking\n      // further calls of this.loadNext\n      if (!list.length) {\n        this._log('zero items get, returning []/rest of pool')\n        this.endReached = true\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n        return null\n      }\n\n      //put (mapped and) filtered items in pool\n      const filteredList = await this.filter(list, [...this.resultPool])\n\n      this.resultPool = this.resultPool.concat(filteredList)\n\n      // getting possible next poll - this should be done before first possible\n      // contentful resolve()\n      const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n      if (typeof nextAsyncFunc === 'function') {\n        this.asyncFunction = nextAsyncFunc\n      } else {\n        this.endReached = true\n      }\n\n      //if pool reached target number - resolve items and remove them from pool\n      if (this.resultPool.length >= targetCount) {\n        this._log('pool reached the target count. set pause.')\n\n        const list = await this.transformResponse(this.resultPool.splice(0, targetCount))\n\n        resolve({ list, reason: 'reached target count' })\n        this._log('(rest of pool:', this.resultPool)\n        return null\n      }\n\n      loadCount++\n\n      if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad) {\n        // if pool hasn't reached the target number, but it's last poll according to\n        // maxTriesPerLoad\n        this._log('max tries reached. returning what\\'s found so far')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'max polls reached' })\n        return null\n\n      } else if (!this.endReached) {\n        //if pool hasn't reached target number, but there's more to load\n        this._log('got', this.resultPool.length, 'while target is', targetCount, 'need to load one more time')\n        this._recursiveLoad(resolve, reject, loadCount)\n        return null\n\n      } else {\n        this._log('no next promise available. returning pool')\n\n        const list = await this.transformResponse(this.resultPool.splice(0))\n\n        resolve({ list, reason: 'source ended' })\n      }\n\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  loadNext () {\n    return new Promise((resolve, reject) => {\n      const { targetCount } = this.options\n\n      if (this.resultPool.length >= targetCount) {\n        this._log('target count found in existing pool')\n\n        this.transformResponse(this.resultPool.splice(0, targetCount))\n          .then(list => resolve({ list, reason: 'target count exists in pool' }))\n          .catch(reject)\n\n        return null\n      }\n\n      if (this.endReached) {\n        if (this.resultPool.length) {\n          this._log('no next promise available. returning pool')\n          this.transformResponse(this.resultPool.splice(0))\n            .then(list => resolve({ list, reason: 'source ended' }))\n            .catch(reject)\n        } else {\n          this._log('end was already reached before, no more polling')\n          resolve({\n            list: [],\n            reason: 'polling finished'\n          })\n        }\n        return null\n      }\n\n      this._recursiveLoad(resolve, reject, 0)\n    })\n  }\n\n  _log (...args) {\n    if (this.options.debug) {\n      console.log(...args)\n    }\n  }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //this._log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getError (asyncFunctionResponse) {\n    //this._log('REST getError')\n    if (asyncFunctionResponse.status) {\n      switch (asyncFunctionResponse.status) {\n        case 200:\n          return false\n        case 204:\n          return '204: No Content'\n        default:\n          return asyncFunctionResponse.status\n      }\n    }\n\n    return false\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n    const { itemsPerPage, list, links } = responseContent\n\n    if (\n      !responseContent.links\n      || !responseContent.links.next\n      || (list.length < itemsPerPage && !this.options.loose)\n    ) {\n      // there's nothing to load more\n      return false\n    }\n\n    return this.options.createNextAsyncFunc(links.next, responseContent)\n  }\n\n  createNextAsyncFunc (nextLink, responseContent) {\n    return () => {\n      const link = nextLink.split('api/core/v3')[1]\n      if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n      if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n    }\n  }\n\n  constructor (asyncFunction, filter, options = {}) {\n    super(asyncFunction, filter, options)\n\n    const optionsDefaults = {\n      // loose:true means that (list.length < itemsPerPage) doesn't mean list has ended.\n      // Useful for jive REST \"/activity\" endpoint\n      loose: false,\n      method: 'get',\n      createNextAsyncFunc: ::this.createNextAsyncFunc\n    }\n\n    this.options = { ...optionsDefaults, ...this.options, ...options }\n  }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n  getList (asyncFunctionResponse) {\n    //console.log('REST getList')\n    const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n    return responseContent.list || []\n  }\n\n  getNextAsyncFunc (asyncFunctionResponse) {\n    if (typeof asyncFunctionResponse.getNextPage === 'function') {\n      return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n    }\n\n    return false\n  }\n}\n\nexport default {\n  ContinuousLoader,\n  ContinuousLoadJiveREST,\n  ContinuousLoadJiveOSAPI\n}"]}