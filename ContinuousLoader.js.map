{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","getNextAsyncFunc","getError","getList","getResponseContent","resultPool","endReached","resolve","reject","loadCount","log","Error","length","splice","reason","concat","nextAsyncFunc","recursiveLoad","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","file":"ContinuousLoader.js","sourcesContent":["import {promiseOsapiRequest, promiseRestPost, promiseRestGet} from './fetchPromise'\n\nexport class ContinuousLoader {\n\n    getError(asyncFunctionResponse) {\n        return asyncFunctionResponse.error || false\n    }\n\n    getList (asyncFunctionResponse) {\n        return asyncFunctionResponse.list || []\n    }\n\n    getResponseContent (asyncFunctionResponse) {\n        return asyncFunctionResponse\n    }\n\n    /**\n     * Overrideable function to create new promise-returning function\n     * @param asyncFunctionResponse\n     * @returns {function|boolean} - should return async function (one that returns promise),\n     * NOT promise itself\n     */\n    getNextAsyncFunc(asyncFunctionResponse){\n        console.warn('getNextAsyncFunc should be defined in either options or child class')\n        return false\n    }\n\n    /**\n     * Constructs a class instance\n     * @param {function} asyncFunction - should return Promise\n     * @param {function} filter - should return array\n     * @param {object} [options]\n     */\n    constructor(asyncFunction, filter, options = {}) {\n\n        const optionsDefaults = {\n            debug: false,\n            targetCount: 10,\n            maxTriesPerLoad: 5,\n            getNextAsyncFunc: ::this.getNextAsyncFunc,\n            getError: ::this.getError,\n            getList: ::this.getList,\n            getResponseContent: ::this.getResponseContent\n        }\n\n        this.options = {...optionsDefaults, ...options}\n\n        this.asyncFunction = asyncFunction\n        this.filter = filter\n        this.resultPool = []\n        this.endReached = false\n    }\n\n    async recursiveLoad(resolve, reject, loadCount){\n        try {\n            const asyncFunctionResponse = await this.asyncFunction()\n\n            const {\n                getError,\n                getList,\n                getNextAsyncFunc,\n                targetCount,\n                maxTriesPerLoad\n            } = this.options\n\n            this.log('asyncFunctionResponse', asyncFunctionResponse)\n\n            // catch errors\n            const error = getError(asyncFunctionResponse)\n            if (error) throw new Error(error)\n\n            //getting list\n            const list = getList(asyncFunctionResponse)\n\n            //if unfiltered list is empty - means nothing to load\n            // returning the rest of result poll (if any) and blocking\n            // further calls of this.loadNext\n            if (!list.length) {\n                this.log('zero items get, returning []/rest of pool')\n                this.endReached = true\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n                return null\n            }\n\n            //put filtered items in pool\n            this.resultPool = this.resultPool.concat(this.filter(list))\n\n            // getting possible next poll - this should be done before first possible\n            // contentful resolve()\n            const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n            if (typeof nextAsyncFunc === 'function'){\n                this.asyncFunction = nextAsyncFunc\n            }\n\n            //if pool reached target number - resolve items and remove them from pool\n            if (this.resultPool.length >= targetCount) {\n                this.log('pool reached the target count. set pause.')\n                resolve({\n                    list: this.resultPool.splice(0, targetCount),\n                    reason: 'reached target value'\n                })\n                this.log('(rest of pool:', this.resultPool)\n                return null\n            }\n\n            loadCount++\n\n            if (loadCount >= maxTriesPerLoad){\n                // if pool hasn't reached the target number, but it's last poll according to\n                // maxTriesPerLoad\n                this.log(\"max tries reached. returning what's found so far\")\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'max polls reached'\n                })\n                return null\n\n            } else if (typeof nextAsyncFunc === 'function') {\n                //if pool hasn't reached target number, but there's more to load\n                this.log('got', this.resultPool.length, 'while target is', targetCount ,'need to load one more time')\n                this.recursiveLoad(resolve, reject, loadCount)\n                return null\n\n            } else {\n                this.log('no next promise available. returning pool')\n                this.endReached = true\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n            }\n\n        } catch (error) {\n            reject(error)\n        }\n    }\n\n    loadNext() {\n        return new Promise((resolve, reject) => {\n\n            if (this.endReached) {\n                this.log('end was reached before, no more promising')\n                resolve({\n                    list: [],\n                    reason: 'polling finished'\n                })\n                return\n            }\n\n            this.recursiveLoad(resolve, reject, 0)\n        })\n    }\n\n    log(...args){\n        if (this.options.debug){\n            console.log(...args)\n        }\n    }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //this.log('REST getList')\n        const responseContent = this.getResponseContent(asyncFunctionResponse)\n        return  responseContent.list || []\n    }\n\n    getResponseContent (asyncFunctionResponse) {\n        //this.log('REST getResponseContent')\n        return asyncFunctionResponse.content || asyncFunctionResponse\n    }\n\n    getError(asyncFunctionResponse) {\n        //this.log('REST getError')\n        if (asyncFunctionResponse.status) {\n            switch (asyncFunctionResponse.status) {\n                case 200:\n                    return false\n                case 204:\n                    return '204: No Content'\n                default:\n                    return asyncFunctionResponse.status\n            }\n        }\n\n        return 'Unable to find status of async function response'\n    }\n\n    getNextAsyncFunc (asyncFunctionResponse){\n        const responseContent = this.getResponseContent(asyncFunctionResponse)\n\n        const {itemsPerPage, list, links} = responseContent\n\n        if (list.length < itemsPerPage || !responseContent.links || !responseContent.links.next) {\n            // there's nothing to load more\n            return false\n        }\n\n        return this.options.createNextAsyncFunc(links.next, responseContent)\n    }\n\n    createNextAsyncFunc(nextLink, responseContent){\n        return () => {\n            const link = nextLink.split('api/core/v3')[1]\n            if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n            if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n        }\n    }\n\n    constructor(asyncFunction, filter, options = {}){\n        super(asyncFunction, filter, options)\n\n        const optionsDefaults = {\n            method: 'get',\n            createNextAsyncFunc: ::this.createNextAsyncFunc\n        }\n\n        this.options = {...optionsDefaults, ...this.options, ...options}\n    }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //console.log('REST getList')\n        const responseContent = this.getResponseContent(asyncFunctionResponse)\n        return  responseContent.list || []\n    }\n\n    getResponseContent (asyncFunctionResponse) {\n        //console.log('REST getResponseContent')\n        return asyncFunctionResponse.content || asyncFunctionResponse\n    }\n\n    getNextAsyncFunc(asyncFunctionResponse){\n        if (typeof asyncFunctionResponse.getNextPage === 'function'){\n            return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n        }\n\n        return false\n    }\n}\n\nexport default {\n    ContinuousLoader,\n    ContinuousLoadJiveREST,\n    ContinuousLoadJiveOSAPI\n}"]}