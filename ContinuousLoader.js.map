{"version":3,"sources":["src/ContinuousLoader.es6"],"names":["ContinuousLoader","asyncFunctionResponse","error","list","console","warn","asyncFunction","filter","options","optionsDefaults","debug","targetCount","maxTriesPerLoad","getNextAsyncFunc","getError","getList","resultPool","endReached","resolve","reject","loadCount","log","Error","length","splice","reason","filteredList","concat","nextAsyncFunc","recursiveLoad","ContinuousLoadJiveREST","responseContent","content","status","itemsPerPage","links","next","createNextAsyncFunc","nextLink","link","split","method","toLowerCase","ContinuousLoadJiveOSAPI","getNextPage"],"mappings":"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","file":"ContinuousLoader.js","sourcesContent":["import {promiseOsapiRequest, promiseRestPost, promiseRestGet} from './fetchPromise'\n\nexport class ContinuousLoader {\n\n    getError(asyncFunctionResponse) {\n        return asyncFunctionResponse.error || false\n    }\n\n    getList (asyncFunctionResponse) {\n        return asyncFunctionResponse.list || []\n    }\n\n    /**\n     * Overrideable function to create new promise-returning function\n     * @param asyncFunctionResponse\n     * @returns {function|boolean} - should return async function (one that returns promise),\n     * NOT promise itself\n     */\n    getNextAsyncFunc(asyncFunctionResponse){\n        console.warn('getNextAsyncFunc should be defined in either options or child class')\n        return false\n    }\n\n    /**\n     * Constructs a class instance\n     * @param {function} asyncFunction - should return Promise\n     * @param {function} filter - should return array\n     * @param {object} [options]\n     */\n    constructor(asyncFunction, filter, options = {}) {\n\n        const optionsDefaults = {\n            debug: false,\n            targetCount: 10,\n            maxTriesPerLoad: 5,\n            getNextAsyncFunc: ::this.getNextAsyncFunc,\n            getError: ::this.getError,\n            getList: ::this.getList\n        }\n\n        this.options = {...optionsDefaults, ...options}\n\n        this.asyncFunction = asyncFunction\n        this.filter = filter\n        this.resultPool = []\n        this.endReached = false\n    }\n\n    async recursiveLoad(resolve, reject, loadCount){\n        try {\n            const asyncFunctionResponse = await this.asyncFunction()\n\n            const {\n                getError,\n                getList,\n                getNextAsyncFunc,\n                targetCount,\n                maxTriesPerLoad\n            } = this.options\n\n            this.log('asyncFunctionResponse', asyncFunctionResponse)\n\n            // catch errors\n            const error = getError(asyncFunctionResponse)\n            if (error) throw new Error(error)\n\n            //getting list\n            let list = getList(asyncFunctionResponse)\n\n            //if unfiltered list is empty - means nothing to load\n            // returning the rest of result poll (if any) and blocking\n            // further calls of this.loadNext\n            if (!list.length) {\n                this.log('zero items get, returning []/rest of pool')\n                this.endReached = true\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n                return null\n            }\n\n            //put (mapped and) filtered items in pool\n            const filteredList = await this.filter(list, [...this.resultPool])\n\n            this.resultPool = this.resultPool.concat(filteredList)\n\n            // getting possible next poll - this should be done before first possible\n            // contentful resolve()\n            const nextAsyncFunc = getNextAsyncFunc(asyncFunctionResponse)\n            if (typeof nextAsyncFunc === 'function'){\n                this.asyncFunction = nextAsyncFunc\n            }\n\n            //if pool reached target number - resolve items and remove them from pool\n            if (this.resultPool.length >= targetCount) {\n                this.log('pool reached the target count. set pause.')\n                resolve({\n                    list: this.resultPool.splice(0, targetCount),\n                    reason: 'reached target count'\n                })\n                this.log('(rest of pool:', this.resultPool)\n                return null\n            }\n\n            loadCount++\n\n            if (maxTriesPerLoad > 0 && loadCount >= maxTriesPerLoad){\n                // if pool hasn't reached the target number, but it's last poll according to\n                // maxTriesPerLoad\n                this.log(\"max tries reached. returning what's found so far\")\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'max polls reached'\n                })\n                return null\n\n            } else if (typeof nextAsyncFunc === 'function') {\n                //if pool hasn't reached target number, but there's more to load\n                this.log('got', this.resultPool.length, 'while target is', targetCount ,'need to load one more time')\n                this.recursiveLoad(resolve, reject, loadCount)\n                return null\n\n            } else {\n                this.log('no next promise available. returning pool')\n                this.endReached = true\n                resolve({\n                    list: this.resultPool.splice(0),\n                    reason: 'source ended'\n                })\n            }\n\n        } catch (error) {\n            reject(error)\n        }\n    }\n\n    loadNext() {\n        return new Promise((resolve, reject) => {\n\n            if (this.endReached) {\n                this.log('end was reached before, no more promising')\n                resolve({\n                    list: [],\n                    reason: 'polling finished'\n                })\n                this.log('(rest of pool:', this.resultPool)\n                return null\n            }\n\n            const {targetCount} = this.options\n\n            if (this.resultPool.length >= targetCount) {\n                this.log('target count found in existing pool')\n                resolve({\n                    list: this.resultPool.splice(0, targetCount),\n                    reason: 'target count exists in pool'\n                })\n                return null\n            }\n\n            this.recursiveLoad(resolve, reject, 0)\n        })\n    }\n\n    log(...args){\n        if (this.options.debug){\n            console.log(...args)\n        }\n    }\n}\n\nexport class ContinuousLoadJiveREST extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //this.log('REST getList')\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n        return  responseContent.list || []\n    }\n\n    getError(asyncFunctionResponse) {\n        //this.log('REST getError')\n        if (asyncFunctionResponse.status) {\n            switch (asyncFunctionResponse.status) {\n                case 200:\n                    return false\n                case 204:\n                    return '204: No Content'\n                default:\n                    return asyncFunctionResponse.status\n            }\n        }\n\n        return false\n    }\n\n    getNextAsyncFunc (asyncFunctionResponse){\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n\n        const {itemsPerPage, list, links} = responseContent\n\n        if (list.length < itemsPerPage || !responseContent.links || !responseContent.links.next) {\n            // there's nothing to load more\n            return false\n        }\n\n        return this.options.createNextAsyncFunc(links.next, responseContent)\n    }\n\n    createNextAsyncFunc(nextLink, responseContent){\n        return () => {\n            const link = nextLink.split('api/core/v3')[1]\n            if (this.options.method.toLowerCase() === 'get') return promiseRestGet(link)\n            if (this.options.method.toLowerCase() === 'post') return promiseRestPost(link)\n        }\n    }\n\n    constructor(asyncFunction, filter, options = {}){\n        super(asyncFunction, filter, options)\n\n        const optionsDefaults = {\n            method: 'get',\n            createNextAsyncFunc: ::this.createNextAsyncFunc\n        }\n\n        this.options = {...optionsDefaults, ...this.options, ...options}\n    }\n}\n\nexport class ContinuousLoadJiveOSAPI extends ContinuousLoader {\n    getList (asyncFunctionResponse) {\n        //console.log('REST getList')\n        const responseContent = asyncFunctionResponse.content || asyncFunctionResponse\n        return  responseContent.list || []\n    }\n\n    getNextAsyncFunc(asyncFunctionResponse){\n        if (typeof asyncFunctionResponse.getNextPage === 'function'){\n            return () => promiseOsapiRequest(asyncFunctionResponse.getNextPage)\n        }\n\n        return false\n    }\n}\n\nexport default {\n    ContinuousLoader,\n    ContinuousLoadJiveREST,\n    ContinuousLoadJiveOSAPI\n}"]}