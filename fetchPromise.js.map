{"version":3,"sources":["src/fetchPromise.jsx"],"names":["entries","createBatchEntry","batchObjectToArray","promiseSingleBatch","Promise","resolve","reject","batch","newBatch","forEach","entry","i","id","request","add","execute","response","error","batchResponseObject","Object","keys","map","content","length","entryArrays","splitArray","Math","ceil","results","concat","pause","promiseBatch","promiseOsapiRequest","promiseOsapiPollingRequest","promiseRestRequest","promiseRestPost","promiseHttpGet","promiseHttpPost","delay","setTimeout","array","chunksNumber","newArray","push","undefined","chunkLength","item","chunkNumber","floor","osapiRequestFunc","jive","corev3","filterFunction","targetNumber","maxIterationCount","list","iteration","getNextChunk","executable","then","getNextPage","reason","filter","catch","href","core","get","v","promiseRestGet","post","args","http","fetchPromise"],"mappings":";;;;;;;;yDAiLO,iBAA4BA,OAA5B,EAAqCC,gBAArC;AAAA,YAEMC,kBAFN,EAMMC,kBANN;AAAA;AAAA;AAAA;AAAA;AAMMA,0CANN,YAMMA,kBANN,CAMyBH,OANzB,EAMkCC,gBANlC,EAMmD;AAClD,mCAAO,IAAIG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,oCAAIC,QAAQ,gBAAMC,QAAN,EAAZ;;AAEAR,wCAAQS,OAAR,CAAgB,UAACC,KAAD,EAAQC,CAAR,EAAc;AAAA,4DACJV,iBAAiBS,KAAjB,EAAwBC,CAAxB,CADI;AAAA,wCACnBC,EADmB,qBACnBA,EADmB;AAAA,wCACfC,OADe,qBACfA,OADe;;AAE1BN,0CAAMO,GAAN,CAAUF,EAAV,EAAcC,OAAd;AACH,iCAHD;;AAKAN,sCAAMQ,OAAN,CAAc,oBAAY;AACtB,wCAAIC,SAASC,KAAb,EAAoB;AAChBX,+CAAOU,QAAP;AACH,qCAFD,MAEO;AACHX,gDAAQW,QAAR;AACH;AACJ,iCAND;AAOH,6BAhBM,CAAP;AAiBH,yBAxBE;;AAEMd,0CAFN,YAEMA,kBAFN,CAEyBgB,mBAFzB,EAE6C;AAC5C,mCAAOC,OAAOC,IAAP,CAAYF,mBAAZ,EAAiCG,GAAjC,CAAqC;AAAA,uCAAO,EAACT,MAAD,EAAKU,SAASJ,oBAAoBN,EAApB,CAAd,EAAP;AAAA,6BAArC,CAAP;AACH,yBAJE;;AAAA,8BA0BCZ,QAAQuB,MAAR,IAAkB,EA1BnB;AAAA;AAAA;AAAA;;AAAA,sCA2BQrB,kBA3BR;AAAA;AAAA,+BA2BiCC,mBAAmBH,OAAnB,EAA4BC,gBAA5B,CA3BjC;;AAAA;AAAA;AAAA;;AAAA;AA+BOuB,mCA/BP,GA+BqBC,WAAWzB,OAAX,EAAoB0B,KAAKC,IAAL,CAAU3B,QAAQuB,MAAR,GAAiB,EAA3B,CAApB,CA/BrB;AAgCKK,+BAhCL,GAgCe,EAhCf;AAiCKZ,gCAjCL,GAiCgB,KAjChB;AAmCUL,yBAnCV,GAmCc,CAnCd;;AAAA;AAAA,8BAmCiBA,IAAIa,YAAYD,MAnCjC;AAAA;AAAA;AAAA;;AAAA;AAAA,+BAoCsBpB,mBAAmBqB,YAAYb,CAAZ,CAAnB,EAAmCV,gBAAnC,CApCtB;;AAAA;AAoCKe,gCApCL;;;AAsCKY,kCAAUA,QAAQC,MAAR,CAAe3B,mBAAmBc,QAAnB,CAAf,CAAV;;AAtCL;AAAA,+BAwCWc,MAAM,CAACnB,IAAE,CAAH,IAAQ,CAAR,KAAc,CAAd,GAAkB,KAAlB,GAA0B,IAAhC,CAxCX;;AAAA;AAmCyCA,2BAnCzC;AAAA;AAAA;;AAAA;AAAA,yDA2CQiB,OA3CR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,K;;oBAAeG,Y;;;;;QA7INC,mB,GAAAA,mB;QAsBAC,0B,GAAAA,0B;QA6DAC,kB,GAAAA,kB;QAiBAC,e,GAAAA,e;QAeAC,c,GAAAA,c;QAaAC,e,GAAAA,e;;AAhKhB;;;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;oMATA;;;;AAWA,SAASP,KAAT,CAAeQ,KAAf,EAAqB;AACjB,WAAO,IAAIlC,OAAJ,CAAY,mBAAW;AAC1BmC,mBAAWlC,OAAX,EAAoBiC,KAApB;AACH,KAFM,CAAP;AAGH;;AAED,SAASb,UAAT,CAAoBe,KAApB,EAA2BC,YAA3B,EAAyC;AACrC,QAAMC,WAAW,EAAjB;;AAEA,SAAK,IAAI/B,IAAI,CAAb,EAAgBA,IAAI8B,YAApB,EAAkC9B,GAAlC,EAAsC;AAClC+B,iBAASC,IAAT,CAAc,EAAd;AACH;;AAED,QAAIH,UAAUI,SAAV,IAAuBJ,MAAMjB,MAAjC,EAAwC;AAAA;AACpC,gBAAMsB,cAAcnB,KAAKC,IAAL,CAAUa,MAAMjB,MAAN,GAAekB,YAAzB,CAApB;;AAEAD,kBAAM/B,OAAN,CAAc,UAACqC,IAAD,EAAOnC,CAAP,EAAa;AACvB,oBAAMoC,cAAcrB,KAAKsB,KAAL,CAAWrC,IAAIkC,WAAf,CAApB;AACAH,yBAASK,WAAT,EAAsBJ,IAAtB,CAA2BG,IAA3B;AACH,aAHD;AAHoC;AAOvC;;AAED,WAAOJ,QAAP;AACH;;AAEM,SAASV,mBAAT,CAA6BiB,gBAA7B,EAA8C;AACjD,WAAO,IAAI7C,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,YAAMO,UAAU,OAAOoC,gBAAP,KAA4B,UAA5B,GAAyCA,iBAAiB,gBAAMC,IAAN,CAAWC,MAA5B,CAAzC,GAA+EF,gBAA/F;;AAEApC,gBAAQE,OAAR,CAAgB,oBAAY;AACxB,gBAAIC,SAASC,KAAb,EAAoB;AAChBX,uBAAOU,QAAP;AACH,aAFD,MAEO;AACHX,wBAAQW,QAAR;AACH;AACJ,SAND;AAOH,KAXM,CAAP;AAYH;;AAED;;;;;;;AAOO,SAASiB,0BAAT,CAAoCgB,gBAApC,EAAsDG,cAAtD,EAAsEC,YAAtE,EAA2G;AAAA,QAAvBC,iBAAuB,uEAAH,CAAG;;AAC9G,WAAO,IAAIlD,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,YAAIiD,OAAO,EAAX;AACA,YAAIC,YAAY,CAAhB;;AAEA,iBAASC,YAAT,CAAsBC,UAAtB,EAAkC;;AAE9BF;;AAEAxB,gCAAoB0B,UAApB,EAAgCC,IAAhC,CAAqC,oBAAY;;AAE7C,oBAAMC,cAAc5C,SAAS4C,WAAT,IAAwB,KAA5C;;AAEA;AACA;;;;;;;AAQA,oBAAI,CAAC5C,SAASuC,IAAT,CAAchC,MAAnB,EAA2B;;AAEvBlB,4BAAQ,EAACkD,UAAD,EAAOM,QAAQ,YAAf,EAAR;AAEH,iBAJD,MAIO;;AAEHN,wDAAWA,IAAX,sBAAoBvC,SAASuC,IAAT,CAAcO,MAAd,CAAqBV,cAArB,CAApB;;AAEA,wBAAIG,KAAKhC,MAAL,IAAe8B,YAAnB,EAAiC;;AAE7BhD,gCAAQ,EAACkD,UAAD,EAAOK,wBAAP,EAAoBC,iDAA+CL,SAA/C,MAApB,EAAR;AAEH,qBAJD,MAIO;;AAEH,4BAAIF,sBAAsB,CAAtB,IAA2BE,aAAaF,iBAA5C,EAA+D;;AAE3D,gCAAIM,WAAJ,EAAiB;;AAEb;AACAH,6CAAaG,WAAb;AAEH,6BALD,MAKO;AACHvD,wCAAQ,EAACkD,UAAD,EAAOM,QAAQ,kBAAf,EAAR;AACH;AAEJ,yBAXD,MAWO;AACHxD,oCAAQ,EAACkD,UAAD,EAAOK,wBAAP,EAAoBC,QAAQ,iCAA5B,EAAR;AACH;AACJ;AACJ;AAEJ,aA5CD,EA4CGE,KA5CH,CA4CSzD,MA5CT;AA6CH;;AAEDmD,qBAAaR,gBAAb;AACH,KAzDM,CAAP;AA0DH;;AAEM,SAASf,kBAAT,CAA4B8B,IAA5B,EAAkC;AACrC,WAAO,IAAI5D,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,wBAAM4C,IAAN,CAAWe,IAAX,CAAgBC,GAAhB,CAAoB;AAChBC,eAAE,IADc;AAEhBH;AAFgB,SAApB,EAGGjD,OAHH,CAGW,oBAAY;AACnB,gBAAIC,SAASC,KAAb,EAAoB;AAChBX,uBAAOU,QAAP;AACH,aAFD,MAEO;AACHX,wBAAQW,QAAR;AACH;AACJ,SATD;AAUH,KAXM,CAAP;AAYH;;AAEM,IAAMoD,0CAAiBlC,kBAAvB;;AAEA,SAASC,eAAT,CAAyB6B,IAAzB,EAA+B;AAClC,WAAO,IAAI5D,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,wBAAM4C,IAAN,CAAWe,IAAX,CAAgBI,IAAhB,CAAqB;AACjBF,eAAE,IADe;AAEjBH;AAFiB,SAArB,EAGGjD,OAHH,CAGW,oBAAY;AACnB,gBAAIC,SAASC,KAAb,EAAoB;AAChBX,uBAAOU,QAAP;AACH,aAFD,MAEO;AACHX,wBAAQW,QAAR;AACH;AACJ,SATD;AAUH,KAXM,CAAP;AAYH;;AAEM,SAASoB,cAAT,GAAgC;AAAA,sCAALkC,IAAK;AAALA,YAAK;AAAA;;AACnC,WAAO,IAAIlE,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAAA;;AAErC,uCAAMiE,IAAN,EAAWL,GAAX,oBAAkBI,IAAlB,EAAwBvD,OAAxB,CAAgC,oBAAY;AACxC,gBAAIC,SAASC,KAAb,EAAoB;AAChBX,uBAAOU,QAAP;AACH,aAFD,MAEO;AACHX,wBAAQW,QAAR;AACH;AACJ,SAND;AAOH,KATM,CAAP;AAUH;;AAEM,SAASqB,eAAT,GAAiC;AAAA,uCAALiC,IAAK;AAALA,YAAK;AAAA;;AACpC,WAAO,IAAIlE,OAAJ,CAAa,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAAA;;AAErC,wCAAMiE,IAAN,EAAWF,IAAX,qBAAmBC,IAAnB,EAAyBvD,OAAzB,CAAiC,oBAAY;AACzC,gBAAIC,SAASC,KAAb,EAAoB;AAChBX,uBAAOU,QAAP;AACH,aAFD,MAEO;AACHX,wBAAQW,QAAR;AACH;AACJ,SAND;AAOH,KATM,CAAP;AAUH;;AAkDD,IAAMwD,eAAe;AACjBpC,kCADiB;AAEjBC,oCAFiB;AAGjBL,4CAHiB;AAIjBoC,kCAJiB;AAKjBjC,oCALiB;AAMjBD,0CANiB;AAOjBD,0DAPiB;AAQjBF;AARiB,CAArB;;kBAWeyC,Y","file":"fetchPromise.js","sourcesContent":["/**\r\n * Created by M. Yegorov on 2016-12-27.\r\n */\r\n\r\nimport osapi from 'jive/osapi'\r\nimport 'core-js/fn/object/keys'\r\nimport 'core-js/fn/array/concat'\r\nimport 'core-js/fn/array/map'\r\nimport 'core-js/fn/array/foreach'\r\nimport 'regenerator-runtime'\r\n\r\nfunction pause(delay){\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, delay)\r\n    })\r\n}\r\n\r\nfunction splitArray(array, chunksNumber) {\r\n    const newArray = []\r\n\r\n    for (let i = 0; i < chunksNumber; i++){\r\n        newArray.push([])\r\n    }\r\n\r\n    if (array !== undefined && array.length){\r\n        const chunkLength = Math.ceil(array.length / chunksNumber)\r\n\r\n        array.forEach((item, i) => {\r\n            const chunkNumber = Math.floor(i / chunkLength)\r\n            newArray[chunkNumber].push(item)\r\n        })\r\n    }\r\n\r\n    return newArray\r\n}\r\n\r\nexport function promiseOsapiRequest(osapiRequestFunc){\r\n    return new Promise((resolve, reject) => {\r\n\r\n        const request = typeof osapiRequestFunc === 'function' ? osapiRequestFunc(osapi.jive.corev3) : osapiRequestFunc;\r\n\r\n        request.execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * todo: нормальная реализация, если надо сделать загрузку один раз, но будте плохо работать если нужна догрузка:\r\n * возвращает не запрошенное количество, а больший кусок. Нужно придумать вариант, при котором вместо родного\r\n * getNextPage используется собственный promiseNextPage, в котором содержатся рекурсия на сам promiseOsapiPollingRequest\r\n * и остаток списка\r\n */\r\n\r\nexport function promiseOsapiPollingRequest(osapiRequestFunc, filterFunction, targetNumber, maxIterationCount = 0) {\r\n    return new Promise((resolve, reject) => {\r\n\r\n        let list = []\r\n        let iteration = 0\r\n\r\n        function getNextChunk(executable) {\r\n\r\n            iteration++\r\n\r\n            promiseOsapiRequest(executable).then(response => {\r\n\r\n                const getNextPage = response.getNextPage || false\r\n\r\n                //todo: собственно начало работы над промисом остатка\r\n                /*const promiseNextPage = function(){\r\n                 return new Promise((resolve2, reject2) => {\r\n                 if (list.length >= targetNumber) {\r\n\r\n                 }\r\n                 })\r\n                 }*/\r\n\r\n                if (!response.list.length) {\r\n\r\n                    resolve({list, reason: 'no results'})\r\n\r\n                } else {\r\n\r\n                    list = [...list, ...response.list.filter(filterFunction)]\r\n\r\n                    if (list.length >= targetNumber) {\r\n\r\n                        resolve({list, getNextPage, reason: `target number reached (on iteration ${iteration})`})\r\n\r\n                    } else {\r\n\r\n                        if (maxIterationCount === 0 || iteration <= maxIterationCount) {\r\n\r\n                            if (getNextPage) {\r\n\r\n                                // recursion here\r\n                                getNextChunk(getNextPage)\r\n\r\n                            } else {\r\n                                resolve({list, reason: 'list end reached'})\r\n                            }\r\n\r\n                        } else {\r\n                            resolve({list, getNextPage, reason: 'maximum iteration count reached'})\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }).catch(reject)\r\n        }\r\n\r\n        getNextChunk(osapiRequestFunc)\r\n    })\r\n}\r\n\r\nexport function promiseRestRequest(href) {\r\n    return new Promise((resolve, reject) => {\r\n        osapi.jive.core.get({\r\n            v:'v3',\r\n            href\r\n        }).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport const promiseRestGet = promiseRestRequest\r\n\r\nexport function promiseRestPost(href) {\r\n    return new Promise((resolve, reject) => {\r\n        osapi.jive.core.post({\r\n            v:'v3',\r\n            href\r\n        }).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport function promiseHttpGet(...args){\r\n    return new Promise ((resolve, reject) => {\r\n\r\n        osapi.http.get(...args).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport function promiseHttpPost(...args){\r\n    return new Promise ((resolve, reject) => {\r\n\r\n        osapi.http.post(...args).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport async function promiseBatch(entries, createBatchEntry){\r\n\r\n    function batchObjectToArray(batchResponseObject){\r\n        return Object.keys(batchResponseObject).map(id => ({id, content: batchResponseObject[id]}))\r\n    }\r\n\r\n    function promiseSingleBatch(entries, createBatchEntry){\r\n        return new Promise((resolve, reject) => {\r\n\r\n            let batch = osapi.newBatch()\r\n\r\n            entries.forEach((entry, i) => {\r\n                const {id, request} = createBatchEntry(entry, i)\r\n                batch.add(id, request)\r\n            })\r\n\r\n            batch.execute(response => {\r\n                if (response.error) {\r\n                    reject(response)\r\n                } else {\r\n                    resolve(response)\r\n                }\r\n            })\r\n        })\r\n    }\r\n\r\n    if (entries.length <= 30) {\r\n        return batchObjectToArray(await promiseSingleBatch(entries, createBatchEntry))\r\n\r\n    } else {\r\n\r\n        const entryArrays = splitArray(entries, Math.ceil(entries.length / 30))\r\n        let results = []\r\n        let response = false\r\n\r\n        for (let i = 0; i < entryArrays.length; i++){\r\n            response = await promiseSingleBatch(entryArrays[i], createBatchEntry)\r\n\r\n            results = results.concat(batchObjectToArray(response))\r\n\r\n            await pause((i+1) % 4 === 0 ? 11000 : 1000)\r\n        }\r\n\r\n        return results\r\n    }\r\n}\r\n\r\n\r\nconst fetchPromise = {\r\n    promiseHttpGet,\r\n    promiseHttpPost,\r\n    promiseOsapiRequest,\r\n    promiseRestGet,\r\n    promiseRestPost,\r\n    promiseRestRequest,\r\n    promiseOsapiPollingRequest,\r\n    promiseBatch\r\n}\r\n\r\nexport default fetchPromise"]}