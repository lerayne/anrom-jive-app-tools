{"version":3,"sources":["src/fetchPromise.jsx"],"names":["promiseOsapiRequest","promiseOsapiPollingRequest","promiseRestRequest","promiseHttpGet","promiseHttpPost","osapiRequestFunc","Promise","resolve","reject","request","jive","corev3","execute","response","error","filterFunction","targetNumber","maxIterationCount","list","iteration","getNextChunk","executable","then","getNextPage","length","reason","filter","catch","href","core","get","v","args","http","post","fetchPromise"],"mappings":"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","file":"fetchPromise.js","sourcesContent":["/**\r\n * Created by M. Yegorov on 2016-12-27.\r\n */\r\n\r\nimport osapi from 'jive/osapi';\r\n\r\nexport function promiseOsapiRequest(osapiRequestFunc){\r\n    return new Promise((resolve, reject) => {\r\n\r\n        const request = typeof osapiRequestFunc === 'function' ? osapiRequestFunc(osapi.jive.corev3) : osapiRequestFunc;\r\n\r\n        request.execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\n/**\r\n * todo: нормальная реализация, если надо сделать загрузку один раз, но будте плохо работать если нужна догрузка:\r\n * возвращает не запрошенное количество, а больший кусок. Нужно придумать вариант, при котором вместо родного\r\n * getNextPage используется собственный promiseNextPage, в котором содержатся рекурсия на сам promiseOsapiPollingRequest\r\n * и остаток списка\r\n */\r\n\r\nexport function promiseOsapiPollingRequest(osapiRequestFunc, filterFunction, targetNumber, maxIterationCount = 0) {\r\n    return new Promise((resolve, reject) => {\r\n\r\n        let list = []\r\n        let iteration = 0\r\n\r\n        function getNextChunk(executable) {\r\n\r\n            iteration++\r\n\r\n            promiseOsapiRequest(executable).then(response => {\r\n\r\n                const getNextPage = response.getNextPage || false\r\n\r\n                //todo: собственно начало работы над промисом остатка\r\n                /*const promiseNextPage = function(){\r\n                 return new Promise((resolve2, reject2) => {\r\n                 if (list.length >= targetNumber) {\r\n\r\n                 }\r\n                 })\r\n                 }*/\r\n\r\n                if (!response.list.length) {\r\n\r\n                    resolve({list, reason: 'no results'})\r\n\r\n                } else {\r\n\r\n                    list = [...list, ...response.list.filter(filterFunction)]\r\n\r\n                    if (list.length >= targetNumber) {\r\n\r\n                        resolve({list, getNextPage, reason: `target number reached (on iteration ${iteration})`})\r\n\r\n                    } else {\r\n\r\n                        if (maxIterationCount === 0 || iteration <= maxIterationCount) {\r\n\r\n                            if (getNextPage) {\r\n\r\n                                // recursion here\r\n                                getNextChunk(getNextPage)\r\n\r\n                            } else {\r\n                                resolve({list, reason: 'list end reached'})\r\n                            }\r\n\r\n                        } else {\r\n                            resolve({list, getNextPage, reason: 'maximum iteration count reached'})\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }).catch(reject)\r\n        }\r\n\r\n        getNextChunk(osapiRequestFunc)\r\n    })\r\n}\r\n\r\nexport function promiseRestRequest(href) {\r\n    return new Promise((resolve, reject) => {\r\n        osapi.jive.core.get({\r\n            v:'v3',\r\n            href\r\n        }).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport function promiseHttpGet(...args){\r\n    return new Promise ((resolve, reject) => {\r\n\r\n        osapi.http.get(...args).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nexport function promiseHttpPost(...args){\r\n    return new Promise ((resolve, reject) => {\r\n\r\n        osapi.http.post(...args).execute(response => {\r\n            if (response.error) {\r\n                reject(response)\r\n            } else {\r\n                resolve(response)\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nconst fetchPromise = {\r\n    promiseHttpGet,\r\n    promiseHttpPost,\r\n    promiseOsapiRequest,\r\n    promiseRestRequest,\r\n    promiseOsapiPollingRequest\r\n}\r\n\r\nexport default fetchPromise"]}